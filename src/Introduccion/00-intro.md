# Prólogo

Lo hemos escuchado muchas veces, más cuando nos vemos envueltos en situaciones
críticas al momento de producir software, necesitamos desarrollar herramientas
que requieren ser rápidas, precisas y de bajo consumo de recursos.

Existe una cantidad vasta de lenguajes de programación, bibliotecas y frameworks
que nos pueden ayudar a realizar nuestro trabajo, aun así no todos son lo que
definiríamos como *"La herramienta correcta"* para el trabajo que necesitamos
entregar en dos semanas a un cliente altamente exigente.

Cuando nos adentramos al lenguaje de programación *Rust* no tenemos línea alguna
que nos espeficique los límites de el lenguaje, pues el objetivo principal de
Rust es el otorgar control, la adquisición de poder e independencia por parte
del programador.

Rust cumple con varios paradigmas y su extensibilidad permite que los
programadores desarrollen sus ideas sin límites que pueden llegas a ser molestos
después de lidiar una o dos veces con ellos, pensemos en lenguajes de
programación como C o C++, estos dos lenguajes son las bases de mucha de la
tecnología usada actualmente, la mayoría de los dispositivos que usamos
cuentan con un sistema operativo escrito mayormente en C o C++, sin embargo
estos lenguajes de programación no son perfectos, el control que le es ofrecido
al usuario no está regulado por criterios de ningún tipo lejos de la sintáxis
y algunas protecciones básicas en la memoria (sin mencionar la protección que
otorga el sistema operativo en muchos casos).

Aun así los lenguajes de programación como C o C++ no poseen una regulación muy
profunda, lo cual puede llevar a cometer los errores más comunes que se conocen
en estos lenguajes como:

* Memory leaks
* Data races
* Stack & Buffer overflow
* Null pointers
* Segfaults
* etc.

